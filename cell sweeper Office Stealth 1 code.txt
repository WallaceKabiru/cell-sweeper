// Cell Sweeper - Professional Minesweeper in Google Sheets


const CONFIG = {
  GRID_SIZE: 8,
  MINE_COUNT: 10,
  PLAYER_START_ROW: 3,
  PLAYER_START_COL: 2, // Column B
  STATS_ROW: 12,
  STATS_COL: 2,
  STATE_ROW: 20, // Row for storing game state
  STATE_COL: 50, // Far right column for state storage (column AX)
  HIDDEN_DATA_ROW: 25, // Far down for hidden mine data
  HIDDEN_DATA_COL: 50  // Far right for hidden mine data
};


function getGameState() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const stateCell = sheet.getRange(CONFIG.STATE_ROW, CONFIG.STATE_COL);
    const stateValue = stateCell.getValue();
    
    if (stateValue && typeof stateValue === 'string' && stateValue.startsWith('{')) {
      return JSON.parse(stateValue);
    }
  } catch (error) {
    console.error('Error getting game state:', error);
  }
  
  return {
    active: true,
    firstMove: true,
    startTime: null,
    revealedCells: [],
    flaggedCells: [],
    minePositions: [],
    hiddenGrid: [] // Store the entire hidden grid data
  };
}


function saveGameState(state) {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const stateCell = sheet.getRange(CONFIG.STATE_ROW, CONFIG.STATE_COL);
    stateCell.setValue(JSON.stringify(state));
    
    // Also hide the state storage area
    hideColumns(sheet, CONFIG.STATE_COL, CONFIG.STATE_COL + 5);
    hideRows(sheet, CONFIG.STATE_ROW, CONFIG.STATE_ROW + 10);
  } catch (error) {
    console.error('Error saving game state:', error);
  }
}


function normalizeGameState(state) {
  return {
    active: state.active !== false,
    firstMove: state.firstMove !== false,
    startTime: state.startTime,
    revealedCells: new Set(state.revealedCells || []),
    flaggedCells: new Set(state.flaggedCells || []),
    minePositions: new Set(state.minePositions || []),
    hiddenGrid: state.hiddenGrid || []
  };
}


function serializeGameState(state) {
  return {
    active: state.active,
    firstMove: state.firstMove,
    startTime: state.startTime,
    revealedCells: Array.from(state.revealedCells),
    flaggedCells: Array.from(state.flaggedCells),
    minePositions: Array.from(state.minePositions),
    hiddenGrid: state.hiddenGrid
  };
}


function hideColumns(sheet, startCol, endCol) {
  try {
    if (startCol <= endCol) {
      sheet.hideColumns(startCol, endCol - startCol + 1);
    }
  } catch (error) {
    console.error('Error hiding columns:', error);
  }
}


function hideRows(sheet, startRow, endRow) {
  try {
    if (startRow <= endRow) {
      sheet.hideRows(startRow, endRow - startRow + 1);
    }
  } catch (error) {
    console.error('Error hiding rows:', error);
  }
}


function hideReferenceAreas(sheet) {
  try {
    // Hide columns beyond the game area (starting from column 20 onwards)
    const maxCols = sheet.getMaxColumns();
    if (maxCols > 20) {
      hideColumns(sheet, 20, maxCols);
    }
    
    // Hide rows below the game area (starting from row 30 onwards)
    const maxRows = sheet.getMaxRows();
    if (maxRows > 30) {
      hideRows(sheet, 30, maxRows);
    }
    
    // Protect the hidden areas to prevent accidental unhiding
    protectHiddenAreas(sheet);
  } catch (error) {
    console.error('Error hiding reference areas:', error);
  }
}


function protectHiddenAreas(sheet) {
  try {
    // Protect the state storage area
    const stateRange = sheet.getRange(CONFIG.STATE_ROW, CONFIG.STATE_COL, 10, 10);
    const protection = stateRange.protect().setDescription('Game data - do not modify');
    
    // Remove all editors except the script
    protection.removeEditors(protection.getEditors());
    if (protection.canDomainEdit()) {
      protection.setDomainEdit(false);
    }
  } catch (error) {
    console.error('Error protecting hidden areas:', error);
  }
}


function onOpen() {
  try {
    const ui = SpreadsheetApp.getUi();
    ui.createMenu('üéÆ Cell Sweeper')
      .addItem('üÜï New Game', 'newGame')
      .addItem('üìä Show Statistics', 'showStats')
      .addItem('‚ùì How to Play', 'showInstructions')
      .addItem('üîß Debug Game State', 'debugGameState')
      .addToUi();
    
    // Initialize game if not already set up
    if (!isGameSetup()) {
      newGame();
    }
    
    // Always ensure reference areas are hidden
    hideReferenceAreas(SpreadsheetApp.getActiveSheet());
  } catch (error) {
    console.error('Error in onOpen:', error);
  }
}


function isGameSetup() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const titleCell = sheet.getRange(CONFIG.PLAYER_START_ROW - 1, CONFIG.PLAYER_START_COL - 1);
    return titleCell.getValue() === 'Project';
  } catch (error) {
    console.error('Error checking game setup:', error);
    return false;
  }
}


function newGame() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    
    // Create and save initial game state
    const gameState = {
      active: true,
      firstMove: true,
      startTime: null,
      revealedCells: new Set(),
      flaggedCells: new Set(),
      minePositions: new Set(),
      hiddenGrid: []
    };
    
    // Clear and setup grids
    clearPlayerGrid(sheet);
    generateMinesInMemory(gameState);
    calculateCluesInMemory(gameState);
    setupPlayerGrid(sheet);
    addInstructions(sheet);
    initializeStats(sheet);
    
    // Hide all reference areas
    hideReferenceAreas(sheet);
    
    // Save the initial state
    saveGameState(serializeGameState(gameState));
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'New game started! Type X to reveal cells, F to flag them.', 
      'üéÆ Cell Sweeper'
    );
  } catch (error) {
    console.error('Error starting new game:', error);
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Error starting game. Please try again.', 
      '‚ùå Error'
    );
  }
}


function clearPlayerGrid(sheet) {
  const playerRange = sheet.getRange(
    CONFIG.PLAYER_START_ROW, 
    CONFIG.PLAYER_START_COL, 
    CONFIG.GRID_SIZE, 
    CONFIG.GRID_SIZE
  );
  
  playerRange.clearContent();
  playerRange.clearFormat();
  playerRange.clearDataValidations();
  
  // Set consistent styling
  playerRange.setBackground('#f3f3f3')
    .setBorder(true, true, true, true, true, true)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle')
    .setFontWeight('bold');
  
  // Fill with "Pending" initially
  playerRange.setValue('Pending');
  
  // Data validation
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(['X', 'F', 'Pending', 'BLOCKED'], true)
    .setAllowInvalid(false)
    .setHelpText('Enter X to reveal, F to flag/unflag')
    .build();
  
  playerRange.setDataValidation(rule);
}


function generateMinesInMemory(gameState) {
  // Initialize empty grid
  gameState.hiddenGrid = Array(CONFIG.GRID_SIZE).fill().map(() => Array(CONFIG.GRID_SIZE).fill(''));
  gameState.minePositions.clear();
  
  // Generate unique mine positions
  const positions = [];
  for (let i = 0; i < CONFIG.GRID_SIZE * CONFIG.GRID_SIZE; i++) {
    positions.push(i);
  }
  
  // Shuffle positions
  for (let i = positions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }
  
  // Place mines in memory only
  for (let i = 0; i < CONFIG.MINE_COUNT; i++) {
    const pos = positions[i];
    const row = Math.floor(pos / CONFIG.GRID_SIZE);
    const col = pos % CONFIG.GRID_SIZE;
    const posKey = `${row},${col}`;
    
    gameState.minePositions.add(posKey);
    gameState.hiddenGrid[row][col] = 'RISK';
  }
}


function calculateCluesInMemory(gameState) {
  for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
    for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
      if (gameState.hiddenGrid[row][col] !== 'RISK') {
        const count = countNearbyMinesInMemory(row, col, gameState);
        gameState.hiddenGrid[row][col] = count === 0 ? '' : count;
      }
    }
  }
}


function countNearbyMinesInMemory(row, col, gameState) {
  let count = 0;
  
  for (let r = -1; r <= 1; r++) {
    for (let c = -1; c <= 1; c++) {
      if (r === 0 && c === 0) continue;
      
      const checkRow = row + r;
      const checkCol = col + c;
      
      if (checkRow >= 0 && checkRow < CONFIG.GRID_SIZE && 
          checkCol >= 0 && checkCol < CONFIG.GRID_SIZE) {
        
        const posKey = `${checkRow},${checkCol}`;
        if (gameState.minePositions.has(posKey)) {
          count++;
        }
      }
    }
  }
  
  return count;
}


function setupPlayerGrid(sheet) {
  try {
    // Column headers (Project Timeline Matrix theme)
    const columnHeaders = ['Project', 'Phase 1', 'Phase 2', 'Phase 3', 'Phase 4', 'Phase 5', 'Budget', 'Status'];
    
    for (let i = 0; i < CONFIG.GRID_SIZE; i++) {
      // Row headers - Project IDs
      sheet.getRange(CONFIG.PLAYER_START_ROW + i, CONFIG.PLAYER_START_COL - 1)
        .setValue(`P2024-0${i + 1}`)
        .setBackground('#d9d9d9')
        .setHorizontalAlignment('center')
        .setBorder(true, true, true, true, true, true);
      
      // Column headers
      sheet.getRange(CONFIG.PLAYER_START_ROW - 1, CONFIG.PLAYER_START_COL + i)
        .setValue(columnHeaders[i])
        .setBackground('#d9d9d9')
        .setHorizontalAlignment('center')
        .setBorder(true, true, true, true, true, true);
    }
    
    // Add title
    sheet.getRange(CONFIG.PLAYER_START_ROW - 1, CONFIG.PLAYER_START_COL - 1)
      .setValue('Project')
      .setBackground('#d9d9d9')
      .setBorder(true, true, true, true, true, true);
  } catch (error) {
    console.error('Error setting up player grid:', error);
  }
}


function ensureFirstClickSafeInMemory(row, col, gameState) {
  const posKey = `${row},${col}`;
  
  // If first click is not on a mine, we're good
  if (!gameState.minePositions.has(posKey)) {
    console.log(`First click at ${row},${col} is already safe`);
    return;
  }
  
  console.log(`First click on mine at ${row},${col} - regenerating safe layout`);
  
  // Clear current mine layout
  gameState.hiddenGrid = Array(CONFIG.GRID_SIZE).fill().map(() => Array(CONFIG.GRID_SIZE).fill(''));
  gameState.minePositions.clear();
  
  // Create list of all positions except the first click position
  const availablePositions = [];
  for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
    for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
      if (r !== row || c !== col) {
        availablePositions.push({ row: r, col: c });
      }
    }
  }
  
  // Shuffle available positions
  for (let i = availablePositions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
  }
  
  // Place mines in first MINE_COUNT positions
  for (let i = 0; i < CONFIG.MINE_COUNT && i < availablePositions.length; i++) {
    const pos = availablePositions[i];
    const newPosKey = `${pos.row},${pos.col}`;
    
    gameState.minePositions.add(newPosKey);
    gameState.hiddenGrid[pos.row][pos.col] = 'RISK';
  }
  
  // Recalculate clues in memory
  calculateCluesInMemory(gameState);
  
  console.log(`Safe layout generated - mine count: ${gameState.minePositions.size}`);
}


function onEdit(e) {
  try {
    // Get current game state
    const gameState = normalizeGameState(getGameState());
    
    // Exit if game is not active
    if (!gameState.active) {
      console.log('Game not active, ignoring edit');
      return;
    }
    
    const sheet = e.source.getActiveSheet();
    const range = e.range;
    const row = range.getRow();
    const col = range.getColumn();
    
    // Check if edit is in player grid
    if (row < CONFIG.PLAYER_START_ROW || row >= CONFIG.PLAYER_START_ROW + CONFIG.GRID_SIZE ||
        col < CONFIG.PLAYER_START_COL || col >= CONFIG.PLAYER_START_COL + CONFIG.GRID_SIZE) {
      return;
    }
    
    const value = range.getValue();
    const gridRow = row - CONFIG.PLAYER_START_ROW;
    const gridCol = col - CONFIG.PLAYER_START_COL;
    const posKey = `${gridRow},${gridCol}`;
    
    console.log(`Edit detected at ${gridRow},${gridCol} with value: ${value}`);
    
    // Handle flagging
    if (value === 'F') {
      handleFlag(sheet, gridRow, gridCol, range, gameState);
      saveGameState(serializeGameState(gameState));
      return;
    }
    
    // Handle revealing
    if (value === 'X') {
      // Check if cell is already revealed or flagged
      if (gameState.revealedCells.has(posKey) || gameState.flaggedCells.has(posKey)) {
        range.setValue('Pending');
        return;
      }
      
      // Handle first move
      if (gameState.firstMove) {
        console.log(`First move detected at ${gridRow},${gridCol}`);
        gameState.startTime = new Date().getTime();
        ensureFirstClickSafeInMemory(gridRow, gridCol, gameState);
        gameState.firstMove = false;
      }
      
      // Reveal the cell
      const gameResult = revealCell(sheet, gridRow, gridCol, gameState);
      
      // Save state after reveal
      saveGameState(serializeGameState(gameState));
      
      // Handle game end
      if (gameResult === 'mine') {
        console.log('MINE HIT - GAME OVER');
        gameOver(sheet, false, gameState);
      } else if (gameResult === 'win') {
        console.log('ALL SAFE CELLS REVEALED - PLAYER WINS');
        gameOver(sheet, true, gameState);
      }
      
    } else if (value !== 'Pending' && value !== '') {
      // Invalid input - reset to Pending
      range.setValue('Pending');
    }
  } catch (error) {
    console.error('Error in onEdit:', error);
    SpreadsheetApp.getActiveSpreadsheet().toast('Game error occurred. Please try again.', 'Error');
  }
}


function handleFlag(sheet, gridRow, gridCol, range, gameState) {
  const posKey = `${gridRow},${gridCol}`;
  
  // Can't flag revealed cells
  if (gameState.revealedCells.has(posKey)) {
    range.setValue('Pending');
    return;
  }
  
  if (gameState.flaggedCells.has(posKey)) {
    // Unflag
    gameState.flaggedCells.delete(posKey);
    range.setBackground('#f3f3f3');
    range.setFontColor('#000000');
    range.setValue('Pending');
  } else {
    // Flag
    gameState.flaggedCells.add(posKey);
    range.setValue('BLOCKED');
    range.setBackground('#ffeb3b');
    range.setFontColor('#d32f2f');
    range.setFontWeight('bold');
  }
  
  // Check win condition after flagging
  if (checkWinCondition(gameState)) {
    gameOver(sheet, true, gameState);
  }
}


function revealCell(sheet, gridRow, gridCol, gameState) {
  const posKey = `${gridRow},${gridCol}`;
  
  // Skip if already revealed
  if (gameState.revealedCells.has(posKey)) {
    return 'already_revealed';
  }
  
  const playerCell = sheet.getRange(
    CONFIG.PLAYER_START_ROW + gridRow,
    CONFIG.PLAYER_START_COL + gridCol
  );
  
  // Remove data validation and mark as revealed
  playerCell.setDataValidation(null);
  gameState.revealedCells.add(posKey);
  
  // Check for mine using in-memory data
  const isMine = gameState.minePositions.has(posKey);
  
  console.log(`Revealing cell ${gridRow},${gridCol}: ${isMine ? 'MINE' : 'SAFE'}`);
  
  if (isMine) {
    // Hit a mine - game over
    playerCell.setValue('RISK')
      .setBackground('#ff6b6b')
      .setFontColor('#ffffff')
      .setFontWeight('bold');
    
    return 'mine';
  } else {
    // Safe cell - get the clue value from memory
    const hiddenValue = gameState.hiddenGrid[gridRow][gridCol];
    
    if (hiddenValue === '' || hiddenValue === 0) {
      // Empty cell - show "Complete" with light gray font
      playerCell.setValue('Complete')
        .setBackground('#ffffff')
        .setFontColor('#666666');
    } else {
      // Cell with number - show the number with normal black font
      playerCell.setValue(hiddenValue)
        .setBackground('#ffffff')
        .setFontColor('#000000');
    }
    
    // Auto-reveal surrounding cells if empty
    if (hiddenValue === '' || hiddenValue === 0) {
      revealSurrounding(sheet, gridRow, gridCol, gameState);
    }
    
    // Check for win condition
    if (checkWinCondition(gameState)) {
      return 'win';
    }
    
    return 'safe';
  }
}


function revealSurrounding(sheet, row, col, gameState) {
  for (let r = -1; r <= 1; r++) {
    for (let c = -1; c <= 1; c++) {
      if (r === 0 && c === 0) continue;
      
      const checkRow = row + r;
      const checkCol = col + c;
      
      if (checkRow >= 0 && checkRow < CONFIG.GRID_SIZE && 
          checkCol >= 0 && checkCol < CONFIG.GRID_SIZE) {
        
        const posKey = `${checkRow},${checkCol}`;
        
        // Only reveal if not already revealed and not flagged
        if (!gameState.revealedCells.has(posKey) && !gameState.flaggedCells.has(posKey)) {
          const result = revealCell(sheet, checkRow, checkCol, gameState);
          // If we hit a mine during auto-reveal, stop the cascade
          if (result === 'mine') {
            return;
          }
        }
      }
    }
  }
}


function checkWinCondition(gameState) {
  const totalCells = CONFIG.GRID_SIZE * CONFIG.GRID_SIZE;
  const totalSafeCells = totalCells - CONFIG.MINE_COUNT;
  const revealedCount = gameState.revealedCells.size;
  
  console.log(`Win check: Revealed ${revealedCount}/${totalSafeCells} safe cells`);
  
  return revealedCount === totalSafeCells;
}


function gameOver(sheet, won, gameState) {
  try {
    console.log(`Game Over - Won: ${won}`);
    
    // Mark game as inactive and save state
    gameState.active = false;
    saveGameState(serializeGameState(gameState));
    
    const endTime = new Date().getTime();
    const duration = gameState.startTime ? Math.floor((endTime - gameState.startTime) / 1000) : 0;
    
    // Remove all data validations to prevent further input
    const playerRange = sheet.getRange(
      CONFIG.PLAYER_START_ROW,
      CONFIG.PLAYER_START_COL,
      CONFIG.GRID_SIZE,
      CONFIG.GRID_SIZE
    );
    playerRange.setDataValidation(null);
    
    if (won) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `üéâ Congratulations! You won in ${duration} seconds!`, 
        'üèÜ Victory!',
        10
      );
    } else {
      // Reveal all mines on loss
      revealAllMines(sheet, gameState);
      SpreadsheetApp.getActiveSpreadsheet().toast(
        'Game Over! Click "New Game" to try again! üí•', 
        'üí£ Boom!',
        10
      );
    }
    
    updateStats(sheet, won, duration);
  } catch (error) {
    console.error('Error in gameOver:', error);
  }
}


function revealAllMines(sheet, gameState) {
  try {
    gameState.minePositions.forEach(posKey => {
      const [row, col] = posKey.split(',').map(Number);
      const playerCell = sheet.getRange(
        CONFIG.PLAYER_START_ROW + row,
        CONFIG.PLAYER_START_COL + col
      );
      
      // Only reveal mines that weren't already hit
      if (!gameState.revealedCells.has(posKey)) {
        playerCell.setValue('RISK')
          .setBackground('#ffcccc')
          .setFontColor('#ff0000')
          .setFontWeight('bold')
          .setDataValidation(null);
      }
    });
  } catch (error) {
    console.error('Error revealing all mines:', error);
  }
}


function resetGame() {
  try {
    newGame();
  } catch (error) {
    console.error('Error resetting game:', error);
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Reset failed. Please try again.', 
      '‚ùå Error'
    );
  }
}


function addInstructions(sheet) {
  const instructions = [
    ' CELL SWEEPER - Office-Friendly Minesweeper',
    '',
    ' HOW TO PLAY:',
    '‚Ä¢ Type X in a cell to reveal it',
    '‚Ä¢ Numbers show nearby mine count',
    '‚Ä¢ Type F to flag/unflag suspected mines. It will display the word (BLOCKED)',
    '‚Ä¢ Reveal all safe cells to win!',
    '',
    'STEALTH MODE: Looks like spreadsheet work!',
    '',
    'PRO TIPS:',
    '‚Ä¢ Start with corners for better odds',
    '‚Ä¢ Use numbers to deduce mine locations',
    '‚Ä¢ Empty cells auto-reveal surrounding areas.',
    '‚Ä¢ Empty cells display (Complete) while unrevealed cells display (Pending)',
    '‚Ä¢ RISK = Mine',
  ];
  
  for (let i = 0; i < instructions.length; i++) {
    sheet.getRange(CONFIG.PLAYER_START_ROW + i, CONFIG.PLAYER_START_COL + CONFIG.GRID_SIZE + 2)
      .setValue(instructions[i])
      .setFontWeight(instructions[i].includes('CELL SWEEPER') ? 'bold' : 'normal');
  }
}


function initializeStats(sheet) {
  try {
    const statsCell = sheet.getRange(CONFIG.STATS_ROW, CONFIG.STATS_COL);
    const statsValue = statsCell.getValue();
    
    if (!statsValue || !statsValue.toString().includes('STATISTICS')) {
      const statsLabels = ['üìä STATISTICS', 'Games Played: 0', 'Games Won: 0', 'Win Rate: 0%', 'Best Time: --'];
      
      for (let i = 0; i < statsLabels.length; i++) {
        sheet.getRange(CONFIG.STATS_ROW + i, CONFIG.STATS_COL)
          .setValue(statsLabels[i])
          .setFontWeight(i === 0 ? 'bold' : 'normal');
      }
    }
  } catch (error) {
    console.error('Error initializing stats:', error);
  }
}


function updateStats(sheet, won, time) {
  try {
    const cells = {
      played: sheet.getRange(CONFIG.STATS_ROW + 1, CONFIG.STATS_COL),
      won: sheet.getRange(CONFIG.STATS_ROW + 2, CONFIG.STATS_COL),
      rate: sheet.getRange(CONFIG.STATS_ROW + 3, CONFIG.STATS_COL),
      best: sheet.getRange(CONFIG.STATS_ROW + 4, CONFIG.STATS_COL)
    };
    
    const parseStatValue = (cell, defaultVal = 0) => {
      const value = cell.getValue();
      if (typeof value === 'string' && value.includes(': ')) {
        const parsed = value.split(': ')[1];
        return parsed === '--' ? defaultVal : (parseInt(parsed) || defaultVal);
      }
      return defaultVal;
    };
    
    let gamesPlayed = parseStatValue(cells.played, 0);
    let gamesWon = parseStatValue(cells.won, 0);
    let bestTime = cells.best.getValue().toString().includes(': ') ? 
      cells.best.getValue().split(': ')[1] : '--';
    
    gamesPlayed++;
    if (won) {
      gamesWon++;
      const currentBest = bestTime === '--' ? Infinity : parseInt(bestTime);
      if (time > 0 && time < currentBest) {
        bestTime = time.toString();
      }
    }
    
    const winRate = gamesPlayed > 0 ? Math.round((gamesWon / gamesPlayed) * 100) : 0;
    
    cells.played.setValue(`Games Played: ${gamesPlayed}`);
    cells.won.setValue(`Games Won: ${gamesWon}`);
    cells.rate.setValue(`Win Rate: ${winRate}%`);
    cells.best.setValue(`Best Time: ${bestTime}`);
    
  } catch (error) {
    console.error('Error updating statistics:', error);
  }
}


function showStats() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const stats = [1, 2, 3, 4].map(i => 
      sheet.getRange(CONFIG.STATS_ROW + i, CONFIG.STATS_COL).getValue()
    );
    
    const message = `üéÆ Your Cell Sweeper Statistics:\n\n${stats.join('\n')}`;
    SpreadsheetApp.getUi().alert('Statistics', message, SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (error) {
    SpreadsheetApp.getUi().alert('Error', 'Unable to display statistics.', SpreadsheetApp.getUi().ButtonSet.OK);
  }
}


function showInstructions() {
  const instructions = ` Welcome to Cell Sweeper!

This is a stealth version of Minesweeper that looks like a normal spreadsheet.

 How to Play:
‚Ä¢ Type X in a cell to reveal it
‚Ä¢ Numbers show how many mines are in surrounding cells  
‚Ä¢ Type F to flag cells you think contain mines
‚Ä¢ Goal: Reveal all safe cells without hitting a mine

 Pro Tips:
‚Ä¢ Start with corner or edge cells for better odds
‚Ä¢ Use the numbers to deduce mine locations
‚Ä¢ Flag suspected mines to avoid accidents
‚Ä¢ Empty cells auto-reveal surrounding areas
‚Ä¢ Grey font (Complete) = Empty Cells
‚Ä¢ Yellow background with the word (BLOCKED)= flagged cell
‚Ä¢ RISK = Mine


Stealth Mode:
This game looks like spreadsheet work to keep you under the radar!

Good luck, and happy sweeping! `;

  SpreadsheetApp.getUi().alert('How to Play', instructions, SpreadsheetApp.getUi().ButtonSet.OK);
}


function debugGameState() {
  try {
    const gameState = normalizeGameState(getGameState());
    const totalSafeCells = CONFIG.GRID_SIZE * CONFIG.GRID_SIZE - CONFIG.MINE_COUNT;
    
    console.log('=== GAME STATE DEBUG ===');
    console.log(`Game Active: ${gameState.active}`);
    console.log(`First Move: ${gameState.firstMove}`);
    console.log(`Revealed Cells: ${gameState.revealedCells.size}/${totalSafeCells}`);
    console.log(`Flagged Cells: ${gameState.flaggedCells.size}`);
    console.log(`Mine Positions: ${gameState.minePositions.size}`);
    console.log(`Hidden Grid Loaded: ${gameState.hiddenGrid.length > 0}`);
    console.log(`Should Win: ${gameState.revealedCells.size === totalSafeCells}`);
    
    const message = `üîß Debug Info:
Active: ${gameState.active}
Revealed: ${gameState.revealedCells.size}/${totalSafeCells}
Flagged: ${gameState.flaggedCells.size}
Mines: ${gameState.minePositions.size}
Grid Loaded: ${gameState.hiddenGrid.length > 0}
Should Win: ${gameState.revealedCells.size === totalSafeCells}`;
    
    SpreadsheetApp.getActiveSpreadsheet().toast(message, 'Debug Info', 8);
    
    // Force win if conditions are met but game is still active
    if (gameState.revealedCells.size === totalSafeCells && gameState.active) {
      const sheet = SpreadsheetApp.getActiveSheet();
      SpreadsheetApp.getActiveSpreadsheet().toast('Forcing win condition!', 'Debug');
      gameOver(sheet, true, gameState);
    }
  } catch (error) {
    console.error('Debug error:', error);
  }
}


function onResetButtonClick() {
  resetGame();
}


function enforceHiddenColumns() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    hideReferenceAreas(sheet);
  } catch (error) {
    console.error('Error enforcing hidden columns:', error);
  }
}


function emergencyCleanup() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    
    // Clear any data that might be visible in columns beyond the game area
    const maxCols = sheet.getMaxColumns();
    if (maxCols > 15) {
      const cleanupRange = sheet.getRange(1, 16, sheet.getMaxRows(), maxCols - 15);
      cleanupRange.clearContent();
      cleanupRange.clearFormat();
    }
    
    // Re-hide reference areas
    hideReferenceAreas(sheet);
    
    SpreadsheetApp.getActiveSpreadsheet().toast('Reference areas cleaned and hidden', 'Cleanup Complete');
  } catch (error) {
    console.error('Error in emergency cleanup:', error);
  }
}